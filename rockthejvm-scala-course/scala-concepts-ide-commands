SCALA CONCEPTS AND IDE COMMANDS

FUNCTIONS:

- Print code to console: Println(name of value) 

- Functional programming involves working more with immutable vals rather than mutable vars.

- In Scala and in functional programming generally, we use RECURSIVE FUNCTIONS INSTEAD OF LOOPS. We don't want to use imperative/instructional code with a Scala syntax which is all about producing values.


//TYPES:

- Remember to capitalise the first character of the type: (String, Int, Boolean etc.)


STRINGS (pieces of text in between double quotes):

- Remember to use quotation marks "" when inputting the value of a string.


BOOLEAN:

- Boolean expression values are strictly true or false.
For example val aBoolean: Boolean = True.


INTEGERS:

- You can give Ints the value of other vals say for example x = 144 you can then give y the same value. val y: Int = x
- There are also other integer numerical values that are called shorts and longs.
For example, val aShort: Short = 1234, val aLong: Long = 12345678910 however, if it's too long Scala will complain so when we want Scala to recognise that the value of the Int is a long number we have a capital 'L' at the end of the long Int.


FLOATS:

- Floats are a type pertaining to decimal values. For example val aFloat: Float = 1.5f
Note the 'f' at the end as this tells the Scala compiler that the value is a decimal and not a double.


DOUBLES:

- Doubles are simpled decimal numerical values that you can use without the need for the 'f' after the input for example, val aDouble: Double = 22.22

CHARACTERS:

- Characters are represented via the type "Char". They are single characters between single quotes for example val aChar: Char = 'a'


RUN APPLICATIONS:

- "Extends App" (equivalent to creating a main function, which makes the application runnable)


CREATING VALUES:

- Syntax for declaring a value (val): val (name) x; (type) Int = (then the value of x)
- Compiler can infer types (reads right to left) so val x = 144 works just as well as val x: Int = 144


// VARIABLES:

- In Scala, variables are represent by 'var'.
- Unlike values 'val', variables 'var' can be reassigned, changed becuase they're mutable whereas values are immutable.


WHAT ARE VARIABLES USED FOR:

- Variables in functional programming are used for what's known as side effects. 
- Side effects are useful because they allow us to see what our programs are doing.
- An example of a side effect would be reassigning the value of a variable 'var', printing something to the console "println()" or displaying something on the screen.
- We must be mindful of side effects and keep track of them.

- Side effects in relation to functions. A side effect is when a function relies on, or modifies, something outside its parameters (parameter: a special kind of VARIABLE that refers to one of the pieces of data within a function that's provided as input in the function) to do something. For example, a function which reads or writes from a variable outside its own arguments, a database, a file, or the console can be described as having side effects.


// FUNCTIONS: 

-  A function is a self-contatined block of code that performs a specific task or operation. 

WHAT ARE FUNCTIONS USED FOR:

- Functions are used to modularise and organise code, making it more manageable and reusable. They typically take input parameters, perform some operations and return a result in the console.

- Functions help to break down complex tasks into smaller, more manageable parts, enhancing code organisation, readability, and reusability.


FUNCTION EXAMPLE:

- Adding function: 

def add(x, y):
return x + y
 (def is short for define. Used to define functions)


RELATIONAL OPERATIONS:

1. *Less Than or Equal To*: The symbol for "less than or equal to" is ≤ or <=. (n <= 0 means that "n" is less than or equal to 0)

2. *Greater Than or Equal To*: The symbol for "greater than or equal to" is ≥.

3. *Equal To*: The symbol for "equal to" is =.

4. *Not Equal To*: The symbol for "not equal to" is ≠ or !=.

5. *Less Than*: The symbol for "less than" is <.

6. *Greater Than*: The symbol for "greater than" is >.

7. *Addition*: The symbol for addition is +.

8. *Subtraction*: The symbol for subtraction is -.

9. *Multiplication*: The symbol for multiplication is * or ×.

10. *Division*: The symbol for division is / or ÷.

11. *Modulus (Remainder)*: The symbol for modulus (remainder) is %.

12. *Exponentiation*: The symbol for exponentiation is ^.

These symbols are used in mathematics, programming, and various other fields to represent different operations and relationships between numbers and values.


WHAT ARE FACTORIALS OF NUMBERS?

The factorial of a number is a mathematical operation that represents the product of all positive integers from 1 to that number. It's denoted by the number followed by an exclamation mark (!). For example:

- The factorial of 0 (0!) is defined as 1.
- The factorial of 1 (1!) is also 1.
- The factorial of 2 (2!) is 2 x 1 = 2.
- The factorial of 3 (3!) is 3 x 2 x 1 = 6.
- The factorial of 4 (4!) is 4 x 3 x 2 x 1 = 24.

Factorials are often used in mathematics and combinatorics to count permutations and combinations, among other applications. The factorial of a number grows rapidly as the number increases.


WHAT ARE FACTORIAL FUNCTIONS?

 A factorial function calculates the product of all positive integers from 1 up to a given positive integer. It is often denoted as “n!” and is defined as:

n! = n × (n - 1) × (n - 2) × … × 3 × 2 × 1

Here’s how a factorial function can be implemented in different programming languages with examples:

Python:

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

# Example usage:
result = factorial(5)
print(result)  # Output: 120 (5! = 5*4*3*2*1 = 120)

JavaScript:

function factorial(n) {
    if (n === 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

 Scala:

 def factorial(n: Int): Int =
    if ( n <= 0) 1
    else n * factorial(n - 1)


These examples illustrate how to implement a factorial function in different programming languages. The function recursively calls itself with decreasing values of n until it reaches the base case (0), at which point it returns 1. This recursion continues until the original value of n is reached, and the factorials are multiplied together to find the result.


FIBONACCI NUMBERS BREAKDOWN:

A Fibonacci number is a sequence of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence typically begins as follows:

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on.

In mathematical terms, the Fibonacci sequence is defined as:

F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2) for n > 1

This means that each number in the sequence (starting from the third number) is the sum of the two previous numbers. The Fibonacci sequence has many interesting mathematical properties and is found in various natural phenomena, such as the growth patterns of plants, the arrangement of leaves on stems, and in the analysis of financial markets. It's also a popular topic in mathematics and computer science due to its recursive nature and applications in algorithms and programming.


FIBONACCI FUNCTIONS

Fibonacci functions are functions that generate Fibonacci numbers. There are different ways to implement such functions, and one common approach is to use recursion. Here’s an example of a Fibonacci function in Scala using recursion:

def fibonacci(n: Int): Int = {
  if (n <= 1) {
    return n
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2)
  }
}

// Example usage:
val n = 10
val result = fibonacci(n)
println(s"The $n-th Fibonacci number is: $result")

In this Scala example:

	1.	The fibonacci function takes an integer n as input and returns an integer.
	2.	It first checks if n is less than or equal to 1. If so, it returns n because the Fibonacci sequence starts with 0 and 1.
	3.	If n is greater than 1, the function recursively calls itself with n - 1 and n - 2, then adds the results of these two recursive calls. This process continues until n reaches the base cases.
	4.	The example calculates and prints the 10th Fibonacci number.

The output will be:

The 10-th Fibonacci number is: 55

This Scala code demonstrates a straightforward way to implement a Fibonacci function using recursion. However, note that this approach can be inefficient for large values of n due to redundant calculations. There are more efficient techniques, such as memoization or iterative methods, for calculating Fibonacci numbers for large n.


MISC:

- Semi colons are not necessary in Scala for expressions that are on their own line unlike C.
- Semi colons ARE necessary if you write multiple expressions on the same line but this is bad style. They would be mandatory where you have multiple expressions on the same line becuase they separate the expressions.